<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"dafaa05fe9dcac205c9101a50732013f3873515bcece6256a438c9a8216b0dbb94327f0264a48de2f98897cdbe0cfe7c494a9cc0fd9610438476484ebf59bf8a1712a94afd12f215211a1094b50d9fa4413fe41eb7534dfad22c35f164cc9ec22582115b8758a2663b5a89bc71579ad87c87a59db16f2f49c2d4056e96de1101345bafd9fa38c6748f034037018bde3b420f7744c93ae80c18d8dec38accfa5e9b07e20b4d7472de678babaeb4e47f04f7c333a1843b9335c118a44671373459fff5f0ff771c2336bcf4b633be6987175b04262796fda7d08c6fec6e9ccec75d51385d41415e3297509932195f0307f2ae5edc029e3000c0438cfecc129500cce1ba1d58146555ee39716d60b92fd81b20f173245b71bade1fe1d12331f862e590afbfc85c2ad98f326a4078158dc158ef5ba8278d31fa0dc95368608128c3c484278d13d08a56990cd01c7db563e4edd2149034b09d49491731687ce871f08e5bfcddb7688e6f320b9bdd3ba6c2cdaed2d1932bc5e884641742167e4839b22ab112b8ee524933da3fbe4e0d0f2af494846659f5c9477784c394afe5505a25f5074cef69d66cd6299a105df02c31c7b25b0020f2ab935e191653e3d9111eb8a9368e06ab927af9456cbd18368046bf2d75ff8546228a3fa85e4b448f4e449b98af70e09a8e6eb1dfc00c976ce1f4579cf8a67b6bbd02db8e4f0301d9bba95228df9a08829f8cc8bb29290689ee7a220c9f75cee66fd98f0e18c8bf7a28bcdf8ab092bca28afbc611cd32906c0b0096349955f9f3e1fa9c9bd20f1e15dbec8e718b45952fa23be4b3bc7c70f378bde10f480bf6d3893a6de726816aa936e425dfbe624cf3b818033b93435d7485a128efc99718ff627d89bf5876b6f4b1754944a455f239d6864dc50d85beb405e6a0fdda2c0b47dc572dfec346858e1ed25d90de852919ad607f47a653fed2c51165a0ffe4bdd9b7b00a8da3371c3a3c6cdf088c083a255ca54e6fb36d579c38aab267ac2c44497b945c1fbe511659e3db906c0c5c98b1c10496c3ed742eaafd93b61ca753c196a66355ae959f9069a882dcb51cd833f41926d3acc43721d62030ce12c05cd00b764ae88c9f9dff8fb1f8712524e78bc8b9be7905bb727263538b64fca1db3fba1449787c7327205175efddef9e7749842e6556b10735cd43018fa8d61d41203577d19872966f1fa6a0ccf8233a29d49c892151dd4a70695752a51b41bb0951e0ac4e8ce00090c5a1d91a3f0a52257ae7af6a8b16ff5f3fbe46d70f0858e61ee52becda15607a3ca97df046ceeb8eac5a55ac77a8459ce6c514c6b6f2b614c63c9a3cecce800dff6dfd3001f653112445823ef35a81a0e88baeff963e30f0e9df7b0dd5ccda0914492938ba5c13f183f9a41cb14c8c7c74d9e533c47fe9f0df1b17633e1ff2925e3b709bd40f4ac2a6a8dab2b53e6201562c0a2a8fb4e07c05b675ee45aa4fd3082f351efd1c6ccea7f4b732135961f455a9bd4591a7e3d748aad0fbc71db936e891bd6e93f9a53eee1fbac6b21aee0bd1c2be92c38f0bcc9aebd09a837d98261f178591530a65090a12c50c5dd0aa3aaa6d9407b5f019b19a96e6f034eaca57a8ccee58ba0950683fe0b8dd7480a90bd2df2e646c8f9fedf775e33f7e8dc97a060be56564cc653d716a45a76099412b6098a2b6a477eca314d502ca0cb765859d7b223c63ce77274a7754d742f747637939b2dedfb0aa50c665a700fe7cc9c3a79b6fc7f53eca5ab92980695bd521fb308c8bb608f3d7dca614792b6290b695efe3f7cc78d2bcb0595307852b0b09efb08e41fe46e4a5104841bca5e04bca5bcba7567b2efeb673f1d57c3f7ec5bdb53178a3b4e1c5d8755931b877dc7093c61d24e99b86492ec07af06e083bc63311aa7995611d62c92781814eed18eaecb0f4fd4fc4a7a2e02ad8e2cd48d22cd9291c7b8e560090987eaf8fd84b7c6567a150776292804ef56dc2eed327099a40662c27709dd3029ad61f949cc35ecaa097b5d958356337cad3d7ebbaaebeb996f140d4a0254640ce0c448b50a02f2d9904c674f822044d4924196000fd82a0889ef36cadff5d6550517f9d5ce1f9e5efa9277b5d9670cbb88a33f7dd3d6909f54014725f78fe4d93dfa4bd352b605bc4169dbff92f51721d792a5af6d965eb567e984ce04ca5a0af366c53f47a19d04430ff3f7e1dcce591f1a47023a16a0a8c76387d8601b8d1c37449e3c10c0409dffd466e85cad5059289899948b86a3abcd90d2a12ab205069dcbade686f5e24a57d5706770b1725f5e8a1c711fb0df9996b49beb95722f2d7a21bea16f3379e46108dba4864ed4afffbd0238da864ce72ddf864a8d262cdd0074a094c4f6a79124bc6e412f80562768dc59f7e6a64128176c3e46b222f791a0f24c6185d199bfa00a2b63f1dce5c648a04a75f8bb4eda24457c4bbb4d7e79dfd968363f1b2d8a649cfe32b3aca2f098b45c8fa0c58dbbce0b624e11b5a702531463bd2c24eae6aa6c51d0e0706e1cda2ce24e887ceaedc8f7e84cad3a0d87d26619b579e8284d97312bb641f7890aaa35ffb6862f415fc1e15c7f03087c4f9eee6ecbce256c7f8d9f00cf736c12a54837fc447b2152d6b43453caeb793e810bce2477baa5796c1368063e997aa5438ea3ba470b1998d1f77eb71b178b55c820ac167d4514b7da19d2075f10a9fd827637e402befa8152a784675dd8c81afbd4b38d7f77c81c3ddf8aaf0eb21a7842080fcc396be30b0aa9d92f629a7aa93666bed7597ec7fe2c89c86539c8f043dab407a016a7330105872e07e56127c9a41872857cad2e28f17a57612c8c4ce1998ebdd3215a2adf8893cab4f49b0e3e65ae32b853a69a27c57b281c63ad5870223bbadf868eb028175815a417c336ad83eeb73a7da45a1916dfa3ff34e4e6f0e483098948b36b183a4c75410846603079f22292ff478bd76ea74a954afefadc38b586b7a5b682216daee624a4e507349dca55e5d0b4115b93af8d64d682bc53e86996aff2c69180941060aa62360e42881a5ac54536555b3a40b1d453d1f4b7860ced29ecc53e56b923d3927fe57eccac1dcbeaabd61052852dbf8f5f87575a7747f64d2c1ebdb000076a21faf48accb135517f9f5ded105d16b39b7ab716788296bcec6c0bfa0204b480260122aa5753af94ef9bd2652e27be5d97d8ebcde1b9d95ad4f0bd9e619a36d5f60f36ff118b15420495f7748d33485cb73dc765118da275142f4c814a5f330a7e9d236f14950da47537a07b8995d4d5c2dd79793e3419cdfcffdd1398aedac634fd643c0900ccd15b490383f440dd75ffbb6ea6762c06642d7cc482872bae51929616629de52a5a4c10b376d38955d6f12ac6a5502cd3c4f04093b298b54416a714c750905850e7f885e4befd65ebc988c1484b8427b3bb7fe3c371a83486a72596257fef86cc24d4c8f7c0c0f0e0bbcd60aaa4e79f94fa9f62a388904399ea605baf3ac3d97053c89508bf8e4176ed35800ae74be4b6bf7feff204d5ea8b19c992427ac26e326d99d7e85216f9b0e59b7b28cc2cc264b2961b7f39bbd51f33a369a6b842e6acd7361c86e2d176dee9b3af376c50745a6a2d2a144706c8bbc14ea8467e9b08b73495d27b186eb1e8f92b8e6fa3c4e7b76ea21988b37ade6b671da61ff56aa4177e6b676007f58701c792df37a73e3407e4f6f7e090d36cf0c86914a463bc2b4e8c7960e1739e97fed9ba5e877e1d7162f52e2b3ae0a44b998e0021bf18cb086cad5aa00e710e4ddf658a4623d2c8674a54d93a82c034af92e3c7c9f9c7b136fe515099a7670df4eddcb78ca0c879dfb3bd5d10664dc350b8ba2bd9e0f2ab704f9f049fb8980c59f378f9f65156cac97545afd19cc218c1418666f1b9eb1d4f21c1958d6c32ccb0ab717ccae230087c220f45a6da584cd43536be094fd42dac720b87924f1783682869c1fe79893ffe41c3d0ef251a64d0887886202c9750b12b7e1ae5c9ebdf6abdcdb1285afa6754128f5a01de6486a0d57650a9f756aa2d3f4b418872efbc687ce209ea8a0af95fd7efc6d53a8c3b02983b64c52f5d62af76ef216fe6f745507a48726da055af786bb373ebef62a9f4930655d96f07adcdbd9e03393d1aaa617277ff1c13166c5d3d0ee0bcc87b2f90a73d4bf1a0a50341a1e1a86bb01914115b4c708f72c75dc9e1f187db6eaf48ea6898914fd993541e029275b87c8309b5c617c1832ca755e035bef908fd1e78f13b5cdad79fe1f6993d30ea9019835d272a9e480f5e7e9a2bacdbb41bdb4589f85a5a7f49b1c025b61cd617d16614680c7a240e0fec864c1fb79f50f7d04751766455254a5f53e9b5930f0549fb248cedb045ab6d93bd585823bf5617a6d05ecfc64aebecb775b5966592465ffa01f4399824e99baf6956542dd69d537bfac2b8d45448279480c721bcf347ce1a806023eaf7ddf7bb4ba1efc74ba371dfc9fe47352a80c3679e220d6e5027a85a0e3644b696132f98fcf831c65d84e0373bc884b03aeb1e0dbd2fbc3c60117f6661d4c3587b5877e0bfcc7ea53c071a0d6ff0fddeb9513f1eed7b2903da5d1d62fad0180450fce790d43073af60280e89f0f8db5520122e4862a2113b4e181aced78fb56943fc4a1c7ee825455925029e0fae952c4364605a64b82623f41edc2a1a22776fcc90eea064930926dcb86dfc372cf36ee0310d8fefeaaef978bf7e2df32b6ec1bcc92e656b135e47271014541603b5e01abafccf9a18aa3e5d68e243e7e4602c1ea98787991c9931c463800cd6e6a6b24d3a2c452d90ce7393c6786e414f9fa7ba4350da0c27826b9c43938a9c96326d0b49a6387519ead8eb02f19a4c448865213e4a15b6544d418b24f8b515566eeeec13055edcc9794e720e0391b1fb5f07dde000e89a78b701b597f47bcb926b45a5489798d18051a0baa1027f228528c92ce308582b4cb442e2d69304b01955c6839be2f572d6d268608bcba63ed1a386b951b9bebde4b113ba49c9ca3629cae8760855d15b3ebbfa531e092702832ef8027fb235361ca803b6a14f499183f3b06f9b23aecc89914058341630f7c98cffb6ff284a787646d9608517c211098eb09a5aab11cf871491fd3f50a2c288352b02a7f9df2e5cbe2b3cd4a9130794b84ba6c0481910de50888d9b08f40d1d6649b7e256b14d7a6f18c5548fff382f3530b1fff539cda256de4914f5bd5e82052e4070b3bdd420b11e0683a80f158bb6361caf340fd1bbc73b3d4c172f5ebf80e88dd70e310f0b5cd6babce5baf50f256a6cac9bdfc4944490a911aa33140b0ecae4cc3f482a86ee3b8b027dd42419c3d4a0c0a2d6843c488a31e3151dd0f2baa18dcc9fdfef6370c487b0fb6aeb7c4851d30871fd5515e977c462e1821576d0d3a2abcd45766c0e9f0204b2dfc8210a41c458355d83201098ae45c9451d82b96883ef619328367aa910c3851d56c74b2dfbb67f380db275b78214124c474a63feace6bfee627b855ff52fac1f0856d5fd7d1d1d9ed6e7b1fdadeb3f4cf99c42fa7bc5bec212922c8aff99095f9cb7e1b54d17736d18491eb66886b07033786206c80c8e34c20b64be8e48059db7cd9c864966e2db6862b73d5a90079f86fa44586d013034b6f385b3519532b6de46517cbd6ee8eff7ef1b2610087e07d74cb00cba4465fd9da57ae3e8d825754ea83614d2f06f6d169c59521c17f73f445fdca90cc650692b2b29b2eb6d787a2fb18476986336f92c80e23c9c194e012319461ee944249dacdbb23d9cc3eeabb8290767e4aef2ae4a16576b6c0a4bfe902a28e0723a8230c7a3c091fa4b86d657f93b87e39011a56b5eaad30fd0cfced7744b41bcaa560a13742897524ee02cf773177058394111481228d2cb338dba3acf4b6e2a41a58cc81b51d899d573a6ca313d1a25030ab429bee5dd76140fa9fc56cda1a8fb14ebd2a0ccca3172dfb090bd6ce87a2364d1936b937d7511ae7e2902919d09ebc118db9f0a7c0316570e477aa92a0d97bc951f7e7d8f55fee4dc3265a0ba61a3cea49dd3e80bcfc9a550ae0bf39c669f7ff3478d6383f3f9922ae8f6b4fff3f6be152f5c76b273109de6f469d2748d117895b0a0e3470a83440ab70d35689e0877beff60b8476b944bdb966bb95823a292894f4a3abfffe0261de3afbccacfc180841d1869b8d4045bcc860b2ad132d2cb63e6ec69c3f6bacc806fbe79ef99638e3473f24bef5f80b425901993290633c9ae31bc1108be0009f0f85d851165188ae4d3fa0e24548626603f67f4d675f063d8880bebf89fbeb984ef2f68b444c170c1d191afa1eb5b8068a19e59fbc0c9692361faae8214fbb687cc65bb751763645ad054ede84ee86fdb7668da257ef1ceddd8e263fb9f435fb070189ba2efb3f67481cbb31f6b6d1ea308a5d6fec6eeb56c262d1e26ac9c1fac1f95a275a2eaeeccf12f66263f01e256f3713e4d366ab04bb2566b4feed9609ab5dc121537a184cec94f4c4949ffb4beff0c91c1fdee418f1bb8357b95dc49a517833fe4aae57ae0a7b37ed9d58463aa98d0d358b4629684af46a5f0555b1c2813eb84ca51eac8c62f619b5805fc9ffe3235956b429dabd333bd4f173e8f8e300d4a584807ddc00930538ac259c25068063ee6b4ff1563c812aca400a98361c2802fea6cc9a0c80b7db170e5ddf23bdcdab9d21164e6b0ca3454da3303da894eb8595e00fcdc4385563432516e97919371d80bff9340a007179cf183e0169f4d7cba78bed4b0474be517cad680f9fcb4a8c50e111d24161fe4743a021ed50c3ad989d36dfb3b7f928af8383e90a570452b6a13e0d647ec200aafff268f0583ecf716241f26765bb83034c013dfd74554c24a1e1db899f73843d09e0ab6f94eb9b06d87049bb61f05524929f50f6b6bb001f0118780f2e5f65efff5857ab21d95562133f704757f49eac3a3448736bac698c7a4d5ede066d2f869f167c0a93188bf7d11fb3685594d2ef1ca67e7dac19281d45ef6c57323f95d0cee80aebcd2da8117798bfd9a8d61f98e58d0cde9b9c15000313d525d715dff7b1f7ac17379bf8eb2cb07ca086868659ee8f7f0921ba89624a34c22efab6e9e2e52f64e04a7e501c0a7c333b21f888eefdc3e243732cf6d91fbfb3c6b3d88533596ea7347812e596817c0badfee526d9acda0126b018edb313313723617c22ae17ea4b40f9e8e5385d7b347ed0c2d3c0adabe2bca849e20a0a910d7ec35a8659b275bc98128b3678736bc816ac6ca4a9791aa4b5c2a5ef279925202e4a70444c0f393b451426d1da11920bc1a2daf01e8a76b6020228b8713a04a1449f85891a6999ba5c2a90a76700bc807c454e52994dacc989379538d0603e177c2b264b85220d9568e0b27523bb2a958d9636ba1219739d935103a0041358c7306931438e4ea51aef457d29f300f38778feb2f60c780cca1b25978412bb5c9ca5aee8bb41400a69f81231c90497473437906741b49e330af5ea8f7b7886433f876b5859eb7047c0ed296cfaef4886e1fd608bea22284850e77e9075f824a48fc6ba36d54093ff70936bb0777463da519c8048eacc6382454a3cc24d77e8534df52744fe1b987d908dd444c978984125e8debe0252470a80387bb2b21e95b07e46556d483e22545462973629e379e3fbcd72c2a4dcd52c0778d4321392ded61313749c00c8173b39ff3851650be851742fb41787af6ff3f429dbf978be0b81d769cd1a06f455e9a360d489ad705b8fa471ccef149426ed3a8bd773a565c0107ee04bf0278728557f694959ae6087c6c35d776d1ac56069c870f8c79fdc4c32d588b2a858c347bd7e0a2428f10cb71b7f57d7c666fb60c1669e851116db69e7d2d858643f97788a6d4beb234c63c51079aa46031384e2272b48299a5b44c2dc0d1b8d3bf14d6f554e5d7a97b44e442e17d4f978f1cffea228459e412d10dc4bec892d23d9062989d7a06aa91680a925f22a86e424787276ddcbde595d33b06270cec299ecba2934b58c8997aaeb5da936642449c84281ae6b7fa143eb26f83df06e0a072ef064e86e30e2d9448fd68f16af70402d78a2f1ff441e5512f8ad758d3d3b0adbd6370cc74e71a088e5ee57ef8580bba89745816d8061f9941a4fed3214f0ce63204ae95f00ab5c2bc2bc819af810306792d5c4e9f202750327303d3557a4b283034119128de29dcba2627d4d56c40fd3d706dd0280993590c1dcbb66e7e217b6b3c083a571ee1b9cd10599cd37d9efd07809f5463cff5535c8cdb44d1e55832c9554488fc727d325edaa210d12a060f4bf0840c0f4a6e812d75bf442afab44544bfbacf1600ccff31d6c8774bd761586f60af7168c03f9028fb526a131745d5fd9d2133199f6e9db936e8ff97ceb9ef4be2d9b623e0c51c920f0eeb8b715e5f8a202dd0b10838749ccb272b57d0cccaf816b5dd156b5d1e81994c9e727b5b1dbcbcd52e8c5b04a519fc2c25d5707703c5d4e6621517b67ae6eaf949e2d62238fa322a8f596aeca61d473e8db3aff0e10187dec0665d7d4e2cfb40fd342cff57a0f7e4032a42e6e659d743d32f412d019dfa759be902f776672e7614165fb4ea10db3e6a546a486bbfb55dc8e90152e2b8f93215005e4d7c39defb29fb0c52908accd611251a7a3b84087c7b85c7fcb7333842c90b24fccf81b9cec7935cb8d9a686fb7c013876de222217c173d1b5b62fa993313c3b4fffff3d4c978957fa811fd2c44c2da6475b685e484351287977bc46e4154349445a6e5ff0585ccd4d3aa4bfbd32eca2f794b3fb069ef307660598d800ecc3acb7d5b265d0af60a32b01bc02649e382f1cfe25730e1b8e3c583d07a2264d071ef0c78df3b5a082247b089b9616d552eb083e8c846574853642415f72fb726c167b311e5ceb0dcfe9386f22516f0d1bdf7bc138da7543145c0f01665f8357c972d49c39b6333ec0b1da3e35c898ae176a4c76d9f14365ea91250d51057b240b9b923cba726673ebc2c90dbec8a67e26d037d8f5fff205b0949dcdfcba9a3961242698479da6738c1f02e643063cab9264d3edcee5067f64baa0f29231b83bf28d23c9914897e5c8f8517877275c2465af6e5689f0917d51283e77e738ae019ee8e2779367400b7eba936c953c8c38a066154f63fd167bf95fadb67953891be50012c2ae0e05a89f6aba4fdf8acc506e8c3512d0ff30fedcc5419054154403dda3824628fa45fb7c4261e8e91d7908f5b9934b3d96f05f3782451baa315274778fda9f55751b75d15bf63dc78f33929279fc0d2cb95a616d9f2f81c45f55a58917e9896959e513828998abf359e9c9e8f9d9733bfa0d015324bbd068bca13de4a1123af0a9189e98000fa68e3ac0bc1c67c9201bdfd4abef8e223fe04303db86778de2a9a9144771003469fdcfc88222d13547f86bdf2ccba4b4d6f94ba59e890c412b122c3d9cad5fc88f29d203fabed7f6b0193c93c88082239fa5d3e36c4fa364c07a9e9613faf766f8c785cc16c9127eabc360cf7b339f9e9211243d04100330f9c3b8999107db33490628d2f336cc4568ac19e509bf5c12fe8e195c5473d974ce63702623d83a38425be89baed39b3404f050b8bf61a3e7e68783f31cb7da730c6c38758cdb7c813e8bd19e13421414b2dde77331c7b7c887e5dd5f4209334970ff240b2df92f30a63ead55ab62d4624b0752a6a1dfaf185b29bac139674b0be6947c060523a29d39f9825ede2145113ffc8526b2b7309cf598d1694190a5a29ad3ee6680766f4b4138cc9ceca870f2c69dc87003a82e86347f50a494561798b3c6edb75beba2e432b2c64ce6d215583eb6ce1dacae8bb6d679d4afe3643a2b5e2a0924caca83d34f1d63cc783b82656f57f07b28ec6d80255f6e26e417af98b69326de89fa46bffaac65483e9f42040e064fc769b940667e5dfa2f2cdf32934f659d0994a7ce02029412031b62e6bcddb7a0e21a3c32b61f117f0bc9b2a39464e5c099cea086c073771ea8615c425ac5320540a65c67e54b1e8f43882739132297873ae812c91f7c55501d59b22d132c30e7472e77c135946607c468173c24e9e7d8a6654584903251ba417346b8aec8d7d4f854c10dbd05f221d1a291542dd4f8ca6decfc2cb7726b7e05bed23842c77b718813a3493602a2dd63b31267359c51a82bd67d41ea1c97e0ae470c4052b24199c7346236df595a2a532f916e5dde6d681e4002b5650942b266da9350702238d7cf1c6ba7e264ede246bc3b305413df6a9399a70ed7b7d44903c9c9acbd78123054d457e1cce6304f91c114154133a1153bccb27cbf226b2e6364217e2e77f30e1191bdc4a2bea9c66ebfb03f922b621039cbd136e89cbb77833184bcc963625ca2f3e58ed9eddac45683c01e0f3fb30ddfe96ea83239d49a57e8622db23c91759ed67af991ec45990f0cb4274cdb326dcedf2a9dfa2e2bce3e1e9aa72af50fff4355f02c0a62800f04502987631941550c0ac22265b3e586d0765019af5b85bfa8ae83a681c7f2fe358179668911eb2b4041bb7b36614c6d46c9732d7629b4acea53b58a0a9b2e6bdbc8c116e76d991fd7bdca3b0ce931c450422d733626af0497ebf88c4883252d3d985b7d5a5225dd3b4800a8a6e170a4a68e42995cfaba541215b874f3e2890932bb029bf021e0f3e31bd1d470bae1af1948242b16cc1d2998e0b5dcbecec83002ad3b874d2e9dcf6346d9375fb2519e43971546f9900b1f8f7a203939837fea225431b7730cdf98aada0b1a68f8491d46777f09db1e5817002988bcfbd0f40cb9607297bc4f8f37b2ccc0833c7baad924588438ed802b57271ad61425f5e86528f232692d7c216a5b232a8a2b447334fe31510a4f4c9e052e2ace0ba574ff6f1b51d24fd26d2710d617d7d02bde19f00ae961968126422eb2b7bb3302a66f8fe12a3c297e76618a4ecf8b3eb961f5796ab133a5d9e58efd3ce03afe65fa90e3e852d62e9edfe20c2a4c166baa5f7497838d90b2630fb03f4cad7d7be518d80d9a0d0ba21f80804ecc607b3440abf9fba31e31dbd6dcbcda4920142f4fbfd382372069faeaaf23de5b11e2e5cebbe49ab917cb43ac83b2f089cad488055774b743df40ef225067ced2877b1d628b42e629832e7049a5ed6f099a7a7b2c647bf2998d495a72dffe6234c5a7e8d1f652ea8f75b45f5b1ec1601214129cc4ad016317be60804856cd0ca4da10c0605aafabbedc37085e288624b6d06e22ad0dd9af2ad8f9331e4d9f99b2711d1e215cb98b0754ad77791122cfd5458e6b79837a9d9fd2394c36a6fd8b0cecf6060beddcacc057ad50cc4f3e50ffc97e3f62034bc6e6890f75276789a0abf1c5ce6add550e2126903d5fc4afec0f769552a4efbc376db936bb93b52e33f9b8fb4d37844907eb23dcd75a27e9191fdb117293a429f8e20af8d6eb2e2c2bf2b58cd99d8c2b86dd899850a8291de1c2b7bbb648c3c07ca16ef86adcb7537b650c74c6404fa70c5f658e66383c6b3a8ce261c61095fe149e8109ae697738bbf31fc19d0511df98fae3255900685d7d3fe76414427f0a488392b32518a1492698c91f6f2a18ba796e509cddc616bd468433c3c032085acbc6b97c6b7d49d692cbc14ded31864eec8f3defdd24b07e785503cc9e8f6c5b4fc03dee76299a1a5bd72a3130d47c9765f02c4b5b7bcd1817fa1a20b699454342799689ac30d928facecfed48b20de7808d77c938af730da9908d9078dc92120c918a97c4b513ada3b96c3c57c3664f4058f9210a3f860e34ef94a4ca8098514fc4cc8b77fd85acbb3d3c394930f664cf94ae6a6b370914292e7d95763959fe638e523529dc85b48d121aeb070b067b86ff3d30b7280f27ef65548a27bbde01ee2b5db28eca82dd41d8fad2454ab5a3e89a5bb6197a675046808ce0fda64f63dffd10c2112fa2b86e8983dcee73382b238c45494a17e55e08a951bb2f217529f17b7ba12b78354355c08accaea5a6c3a0bc03447ebed69e31db662548789e136e3bae6b791b0cd5dc4d8f9ce78aefd604b11837cc9e025b3c7fe5879646ff1ce5a2b79be92621b4ecb3498a0f52d6598a5189a30cfeacf193db1bd9740d8b44d51d84c53e6c902be7f73de46e74a094485df98a48297ce7fbe7fc1aafa0a4e76db6fa10656c251b173c02997a5f733167884f39460a9abb5d8b53d63f7292d2f0076e8b41fc0b7e0b8780366cf22afa2b9a223645a20527350bac1a374a5d5008fbfd5b7699c2a0194cb0e5003197ec2f7f8c7f4bf1cabbbd4dfb05f69d7aaa97df93652b3476b6a99e36df4fb87f6c5efd0ce90a7b764db8af262bb147324eb740ee6a474fd040b65aaaa532eb2643a4f7fd6b8efecd14ffa657a8b9d742928158057112405217dc6a0d702531abc19c88c20a99b8dbd390903a4c9a89fb3b2c491deed81e98314e770e99bdcc94555a5edd372ab63a58ff13d562b98a528368a6fa6d56db5f7ba1f850882d559ccb3b35da7d20ca0f5e05d436e29db0f61640eae428452154d5f57b41d0829d09915255275d4de3607b68845f2b2c731eed361b718d1df6c22f94686e30240c81c7ba09e14d97203b32c86daeb5ce10e4e14056816a722d73066c5f04916505487fb84fe549e09b3a16b44fa6fe3947f154090eb7cc3944d42b4e757f161b8d5d8ef9281145d4a0ce767e98bc3e7f799a91ae0c305b127040ec71eed0103590fac695053697c4bd93ccba38729b3475d52b4e5127da4417d3a19f8e6b67406e99b66d63d3a6996417e2fc369ab0fca6d6976a8943d380bada50a9cc779ccb1b1d7e87e13e8f4cd40068336e49f01e586eb687a96f2515dec90cf55a80ccfbd96769043f1c7ab0db58313a56ac06940ee37c9f7c6af55bf80cb4a540601869c72d931fdf75f2a847d58b116cc46c2caa4d959394a37057588953e2651590907069d78409711e9943243f8353b2fe09b9fdc02b1f62d43493cda51c18904a627d8094f01a169c1314dcc52504c170c81e03428ea183a537e113e5cd49ceca063604afc7c2ea7a2acea858fc3de7ecdd23249401658b62538ea057088135b524f60943aa4096fa08ce1ba7eab10174f654318d05e313aed456875079142d2c6068a0bc93bdff875b8c29fb0d6ce8c96329b6460c1f2d5dea670a7c584f075c6577c6500b6bba8af4acbefbe84e8a76591e101d86b5206b5a58c23416c9c98895ec777f44947647e2c2459d8a8866668485c53673d049335db8c4027b3151d0d54c57b2a4149f8b22bbe607b47a89b9dbb02fc584f2702c60ef778b731566758d91c93d94c410a4892fb82ba5a575d4a77413caca24885f44ac131754272c0292849eea9b41d017bda498552463056810638f4dd911962735eced05612eef610c9c6b8596dbb125a81f7e4a7c9e464b420391db57b3059f01c8202ffd0c34f75c08bb0fc1337fa67db1f338a4c8504c2d72fcf9ca9a553fb8563094738e3f0d3536efea2bc201153c629443503b619cb3149526657f1b346038749ca87976f35a3c35c6a537ddc57aa70a02ed14b000e22ca3f4be446eb9a9ba528cee990a1cb8bc27f15f03809e25755db9977acf018a5b0866913af2e94caf7818f5275931f50b355ea2e7f220aa6c313359f9de2c79aa4ffad2d2b1dc28de94cb388e7d34d9de4e847abe84fd85fec6a55f681ff2eaf8f93fb42fe9c49a29bd0ef022296a07e5f1d57cf53b03fc38f7f699a6b6b0c08995a4ccb269165ed30c49cebce2913d1b28e71b9440b695f10587042b61b12579ed2897bb35f35baecf77a98ead08bf541c8d842dacda3dd0877e357f70bc8bedeca5e7bfaed3eb631cfcc13a049b624bba6d68acc1be9b0c46730bcbae7062f98abcb7b788c430c31ccd38a5e9e83d76cb1b687ed6d5fea6a0244fa6bf23b12d00b8c67bd6330438f33d514502b2bfe393bae3a7aed21dc7fd511e47ccc7fac1573cce629c2a0212caf13f894298ffb5788d8c5a7ec15b91728befe56143255936ba7465308c2626d55cb4fa49d2a6da0cd2fc2f27af2289a69233247e67653c3ad35567cffddbf5ab0d9348cbbb901dbbd5c56911d0bc28afbe77138765b17dec31bad48f0b7293daafbebdef0e5532a274bbdabbbc59c81d0591a0e96ccc6f2a963382d8a0ca7adafac7bdf74b57bf3f63c70651aaf654ded6702e6f60f49e7c2c68a3340379281de161f035dc0a902761a24bc6d4f9a98e0357a8aa4f08cb70c0eb8d226b4afaf1dccf43cf138be6d124731c4b2a50a3a9c1c78f9ae886fe65d697a8739350b82d9720193233af2e5f2b0dbb14467db837717f8f29f1b4728b3d42ced6e66d6fbe70b12e10b9182c869a49eec587d397b3304a3947e19f5041d1657315f26af5573a1cc0ad6b6c26ec64c43fe10aaa884906f09aecb4dca82a262eaaee94f521c518680c47f34fdff71ad837f58572dc13779ea7a9928991973c9576fc19fc59494aa409491c11bf050068e5bc2e8d18755ee3b1ed49c3cb8e75f2093f14993e38674b6fec581d68e856371b35af52954c0de43a89cb9f8e67da0b80cca2e7b07c2406efc329d0818e9dd448f3e012ca27f76a801f8521a342eeea2a0b36358659446c973945e04deff58127682b91cbd90692e4201c6f32334a6a9ad23635c6ff3deb6de5e811672baa416bbc97b8df75a5fa032196b1b1e9bd32776cbe8a835e62c2b69c5065a9b45f3ad3755a06f088bf2a3e7eb81d1a26aacee60a417fde2a8e9ea1dea8f90a86cf462a8a082cf7bced9d24ad99e9230d75315aa07f1e70fecb72452a585367cbb6a0e1bc793fe58e580b62a51c6f4c36fa284380b77897ee0fb0611ee283a1876c8fbca2d2841ee967af06338db7880ba44d75575a593b9d7400049a349fbfd9656a5455d4ca231dc41ad1d004b6ad4ff8b83b9c332b14b492df9ae19dcb6b68b22dca2f9c120e5a4e74de4640213cc17af0f368ed9d027a17e28a3210da70a942b160de93d74559b845659a2c3a78b761b7a82682ece43a6d8d50bbb5fa0d9bc6483107b55e512daa0225ea9f676fecebec8c92e0fe22701ba85adff456170461c3a4afa791d4808260d7e0437038ca04cf9af0f9e74ec323322409050a22ec53fac747c9e00c44baeec58b970c97c9bd5bc3eee4c5f3c0b2854a7e8f179e3f2e0b87d4f2ed968eb065e8bfeede4cd3b670c5917e1039d69492ff08075a8ef599bf695c8ae3fba46db5f3d517128f4c3ad04c8c3aa38e30a260741758f04aef3f65a8f2cfb117556812feed9eb76bc23dd9993c2e4ecaccad33f3dcbdcb6c4fc4aa4db58b045f6b90df234c9b549c4ff2d3b7072236196ab69de2638592805cf252853ed9049280b00003f1cfb304c3a5ce15dc976d3efcb373eaf3dda9b28fc96129f8fd21317b8dbdeb9875fca1a6d996d7956fe57b2472ac70e27de828c6a949670de71379ef81e5c1d8201be94a4bd19f3f11ee8e253e015d3197f8dc50a3b50b6fa10750749909a8a8625d56c13ceb048833eb92858329084362bb857b73cc522a761badd18485e8a498281091b45e8c0f49053356a7515c0d6277f328b5d688f2ebaf3f9b5168755a4d1e6787a67117632229aa9cc70b30a5c9a0bd0e18244e58f11af8739391f09adfac5990ecf9bd4472f4a052c2f8285b917c3e36ffad6e4cb02bcb30b0d9ccae925de862a72494bc348dfb7dfbbb2e2b37c371706796e0da37b108c3ced3ca4fda9da584f10073967c3fc8b09dcb765b63b52b2f2f2517d2e59fe1f9c48f124c98feb08dec0c40b54a9f76bc2d6f7549169e1fe8c73222db988ea1b26134034b8befd47bfcc8a7878c65f232a21002441271bb7a832db4f3e9be58133d4a440a09a8ff173a5b4b90c3158613b9c61af4b8139c0bde88ce5b58c3430faa8ee9974e28855aa72ffd8d5b82b973d934efee114f8d6cfd22cce27c9737307978c925421351ba417ef8338993965e1b1ad3d852ef20839e0fd012b22f5687053df45b318ca14364c168c04529a643b920d82f20be07fa24e755effce40bab4ac9c5e570ecff36447a11814d70830fdb619f0c77438b8abf86e65fdf94eb8d4a0896458072b54eafdd5f6d14f89178013d6d6601e37ebe4db8913c2ecc46d0ab6badb625de1afffe63782fa794c31a985405c8f0e1ae28da0d493f981787da019393b6e5062008c1ec746d39f7e23ce56d34d768842239414194a8e0b95a5240a5aacbb2e9072b7e0f62347b6900c31ee476737ff7f40400157e34441b34f435fb07574e36422c7410ff054455925fc804a7017f5ab1d54a615034a9ba2d5bd93644cd5e55794c4e3a7ef5a6418a0613181d013691c9f392d172a1d47e922f63a87f166a3350deb2292c0cb51c2fee14f635bd273367e26791777627b447eed8736910db41e203915f87431c183004f3abe904e5af2ab351a05db7ed92cc1019d81ebff26d2e4be546dd097e1f66ea78617742535f67f6512db2fc1751ac2ab539dbd6fc0fdb420616fe939d8893ce70800c9dcadbec44e255703eb0a57b33aff78439113c059d14e5ef934b539b6829840415fa91bb8958f6ef33cbf36522a1ba2bf6b3bcfa9e1884f290854727c83a8fcdd69f2703d726a8e8306112c0439bc5dfe7c7741efb67f3e14f80c99fc59007553f317e4adcd5fbe0f6272f63a039c9f640d997f695c4d8edd876f8d2bf91dccddec512d1bafb572635f2470c192aaacf8a6749c1cc839774aa61f1ec39aeafe5ceeda8c364e859439483bcdbab591e4787dc8abf7e32032f1fd141e3ede20e1b2fbc662ca6b8f463aba7ecfa39f0c3f67b1c8ad9d4863232c94657765c8e246aa7a4bfe4d798be62b147f7fcfdf5538b0f8e4e08cbdd3611ceff68ffa56052a94d72921f23dc99d242fe91bb2f2aecad381d7908cfa937bb3bae4fd8f18ed6604a15695bcb202e8dde17f9b80fe4ef4adcdd790b47603cdb69ec33295f6ca10fafa49724033ec638806c66eed234c94a574c634cffe818c0be00a72f49cec6c3c15c9c3f41235b0c6b1f94dc33d96412e541c007756a31fd421080769c28d16d99afe90cfcecad2757a8bfb366d9c906313cdb0a70a207f92236e7124e356368c43cee0e95a7f30e86f3bbef33d95e560621885316187f1896387a30ffd731a09873ca6fa5e4e83e43ac3199352bcbac752cf0c55bae228d9738e2859ac788346c47a7fc175b638f9c5b79ea18d524ff20bae9b6c740eba87261464ac407d84016c628193e2cb7812a5aa6ac2d646046f60edf541ae01879b34ba67db36789276e1222b7b3a66f56da0df4c0e164f7c984b67778246d6f1e531b4fa6b1380fca360719b643d99a295663f705673e8f9cf6ac091a02e2460a6ee3f38cbe32a6f379ab7fc103024a93fb6d8eafc40560228bcadd1ada3d351e32924875f41f639e91040f057ce749d8c9d78970f4c16e2f668c707a37a6877cbc64e693be6df00905f1b6a394d1cf2639a5e2419815a3bf65fb54f0a03cdd9d02719c2e2eeb250a6142d9a486b8b0d2b82aa44a99133291882c22fc0a606a31bb7308c58eedc0b770fa1b970bb32cc6f5abaee1c77cad9b211578f7c5156f2f7c410dd637ea8b3dac1f4e39a096c6a37c61d1e5aee97d68f23e098833b5ce278aca2f4adca06ce0ac5170e282f4b8fb77c2910d280eec1acc86387ad2842b09e257aae0b3d440acc7314111c3fb3df36dd2bb8652d36f95f0b8770d855ce3396dfb21c5cb9904b806ae288bda3df897bced1ddcac9b6ee913b7fd15c6e10a6e9ef11e474f072c576d0cafad92f3663de0e30ef589212be260d77cb5ace1cd6b4400ba87f73766837f6e8cbb0009f7ff4308a21224766100b0ef02475d22f7504c2cc1abc7f6aed8e371275ba26f925e71d496ca5407f6d1c4e48c84c1a68d9d6ece2a0859f324883033394c146d7db1054154f05c3dbbcd764e718bee5c49d1b03bec20b41b04b3cc2be128c925ea4b723b3f924935fcfbbc31f7a7e21cc5e388dda7de5de6e2d4ce60ada72e0bfb17dd92b50c498699b840d2620ca17514ae3fdbdc4922000d9c19fd70a1eac7ecaf8a2fa92007b65322781d7d273abecc8f199a5f5aef670702f3d9813ba863558bc235b3fb051d3c25cdfff731fa62d51ee5773244ef68cedf1619c4cb7bbba70d8b2dcb46e6760b68701581a97fe4765b2d8ee9ebb97300fdc2912d4dde1919a6e3f2152d379f6ef5cd46be64056212d0d8af0a8aae0fe92b47364f16832820ee2d2e5ab83428174e7c48b454f49ae5ace81ca722e5b45ede4bb3f82b89dc5809b0c2f63b354c6093919f36bd1219b750e254c9ef65f418537ca328e9fc6074cc237e0db1cc37405a5733584ddbe92dd4c30feaa0857065178ec33655b4a26f3dccdd37e1d0630b4fc9c911b32e55aa1e1dc6f29b28d8e311f17f38e401e1836e595ce6a031d0a39365d40ac233126c0f5bfad67ff99ddd4082bb2d1ef770647a488479b6f03b4252e796f03eb984d95dd108477f1d3a823dd533d1d7cb4934b8519e33ad3e5ab86979cf6847dcf6c097d80f45122db2a66af921ba708cbd801f84f96cbdc8039323b33b2ca729706362858101ab3e045c58ce973b8a4e7e4545dd63cbea3d34ddb4eed0de4b89f33ab75750c3e51e074850a5c0336c30aac03cd45842fd94f0a47d8d8c2d69aa9777044c9bad36847f8d6c87f62f374f48cdbb4c40b059c378516e1dd18dc5089ec15821090c002c56d916366dc65574898d7ae044ce89a82f90f3d49da9821d060ad12b77d01a774b6d62e8ed018f8e494323157739df9cc813938661b22f50955cb5d7780228080be30627eb71710361cd75160fa3abcef0c37379ea1e146bd76e79b69a92c98d1cc9038a359268bf571cd4bf30544b3fd19f3b04a5895c4b231e382de22a5c4523be285b29d9dddcbbf60095f1cc0962ccaf7d02a40188777ba26f23710ead6d6444ae5fd4f1e48d6678435cea8ab143c8b7df7e98b5a0947c183402d3b724daf9778fcd1591e09da0d150f2a32f6fb8b7e107f4828ccc0bcfbcfb9ae6bff4177ed79c2c6c26ce2bffeda40289dc07f06922f3dc8c8c7388b37fef6e612f2c6c7507717256de952fa50dcebc1bcdef7cacd93a53f825b10616afd9f97b5c3a5a9ae0a5e20648aa42ddac0679a932b1fb2b00bfa662f1ca96fecb7516a7fe1fcc0aa7f21a463122920c41835e48f433f2d732988e2027d1bc937c28ec911642a1e09c9ffb39ea7cff513ef8a2517e11db425eedbd11f8756a806e59cf6d4914606c347c8fc117ab2362711bec2af4a3e70c491b382bad1c9f52d9c8f31e1b029ed35ec0748722d116250e2591888e8d572351a7b0a4b0b60e2c7e4aebb6f121566395fad718f56f9e3c48170999425de3373b28d7cf35a608bf0d4b7e20b56e464a617c41036c7e25f326a01a5fe66290f0971ae8ccb999922b7bb3399052aa5ffe1fdb8e79645178ac90dc72344d0939103b6455d5d1626f6bde3792475ea6fabddf688119f57d6632b23cd0d896648bab3aeab8f7046a666f7ad25e3c5f00638f46015e8a26a575c0b21118426e1077c186031b46f43f39813781fb89254d37713077b28689ac580323e38bfe8c68752d920fd5939e266d4990ba7ae35c0ac1306512e1a7ed4adbe8bebb9cfc6c3d230d0d56d61a2b42dd47b49cea056c31d7952bffe657be39b099f2e71171564c43a9dd7270b20efd0697dde3c6e3afb9c37c2e2eade437af7c0953a595f92ebb8d83941ed432f85f3c7d42b3299811ae66d997a447fbf36bdb5d2045a2bda0c157d3883d958ed2406f38e4f0dc22c37ae0696c5307715d89c8bc3e0d7660dabbcc2c3affc50119fdc4bf8154ea2a745871f01c6e9d03b612a04d0a3220e5256c502d655409e7bc36450c958fa9e85f52c8543cf0185af91fe9fff37d4291acdcdfe0c10fc68418f76c493f1b1d523e73e1c4ee52418d2828ecd2f1d0222197e6fd60acf18a4c3765d3cc038f81a6129581f7b8230dbebf2dc19245ed0917c9de351161c2cced49ba5e0877e1d849fb9afc201bc6d9bf109447951a7dc825c17c6b29f02bedd205c74297dcfecf25910519aed7341bd03c4112baa3636eae4fa13ecda33072db2d724dfba88242b7d1f230a0c2b006ca904fb6dc97ccaa37613922482b225c44ccdeaf83dcf401357b92bbad409a7798b45df8b1d0a4b1596aa80371ca765a217d4e0890c130afe2d88d18a3b46b7b52fdb70323cbbfad9261252c27727d1dcc91977754f8f6e2f954a438347385db0f809ac71f60bf2d2294c54559413a1eef0a72909c5744b580cabb02763abe8eefa87bb6e8c61c642dad6a49e560428168e7ee3977c721de77f59b8279be7783679c12429eb2089e54df71ebbfc9cc9817957ef88f3287c2688ff1809a603cd17bc64417b47d5fbc748759ebb4d2c10c9a863ee223ebbcf89691c0062399c733a4556fbfa91ecc4e93dbbd4daaa298f702936ea1b1d05f67f1d966b52157bea9792a04035772887b39eccc3f3f771df47278e79c92dcf24f0bcff85abeaf0bb9af2ee12d1da2da2f03e5f941f89d6844132b7de50fb25d54dbc929d528ec1b1c5ae6e06cf37c32914e8f3f66a69de68253d8735d7260a456bea8c20596ff0b992c9151bdbdd0a78f0825f6fc987d90087f53a353e70307152a47fc42e00350d15e1efa522f547ef780e598a40deb8d04bd3681f2606a502ba62e283473bd8236f7c3a94948f113a51a0bffc5a30a310df70b155e6b3de9fcdd479baca69a258805bc453bd8e00b1564ebcfde36332fdd55ae7f5010c752de5c3372aef26b94561387e686284247fe9633b8e2a460a7778c0eb003df4dad39ca2824359b71ae3dbf94e579721452cfe541826e53b158c40c9a0d226466e1ebcb4427b69d0c5ea6cfca6f4655dd8a2303108576d6629ad19411e0700041e93f09e8c47582202aaab099fffbb9649dbe26aa596d0f8a523ff91464a033605561f1510663ebd588456e481a06cafd1518d6ebb372882ec4162141cfc4bb016ec50a136b0279ef8ddd49282eed5805fc298eb72d8b0fb079c326af0e6210e7f1d0ed29adfc5a35155bba93977097de0d60fc9e0af1a59120e3abddde48dd28ebf17b1e0385b2a674cb29ade9a840fc7a77e3b1325d4e92a2019b4bd24c9c7e77ba2267d4104a6814297b3db87376db686a16632b0ed7916235b6ce212b8f07302f9f46b4f65f858885011e633f57b83a5834a6058bc07349941484f42822b892cf4daeeb154d8aa91b258b09de08ebed2fae624cedb66c11d9b7c50e694a2d1c36f5795178283562b8a7bc79bf9db5537e2bbff7068aa298566ad1d012312d2b48ee661f99b545f225113e00a2b000bec98896927e34e6e8fb75fa1c047c1588b3fc497dbce8960e1cdc65a26da1ca217bff8a1d069c9598eb07341ec3f92bf2443ac01256e06b9fefa4270084194af","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
